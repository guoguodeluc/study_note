双指针（Two Pointer）专题
===
- 双指针滑动的一般写法：左指针不断往右移，至边界条件（具体题目而定）；然后向左移动右指针，直到双指针汇合，进入下一轮循环；
- 通常双指针滑动在**排序**后进行，并在指针移动过程中**跳过重复元素**；

Index
---
<!-- TOC -->

- [三数之和（3Sum）](#三数之和3sum)
- [最接近的三数之和（3Sum Closest）](#最接近的三数之和3sum-closest)
- [下一题](#下一题)

<!-- /TOC -->



### 三数之和（3Sum）
> 三数之和 - 力扣（LeetCode） | https://leetcode-cn.com/problems/3sum/

**问题描述**
```text
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：
    输入：nums = [-1,0,1,2,-1,-4]
    输出：[[-1,-1,2],[-1,0,1]]

示例 2：
    输入：nums = []
    输出：[]

示例 3：
    输入：nums = [0]
    输出：[]

提示：
    0 <= nums.length <= 3000
    -105 <= nums[i] <= 105
```

<details><summary><b>算法简述</b></summary> 

1. 对数组排序；
1. 先**固定一个数**，通常固定第一个数，或者最后一个，两者类似
    - 不建议固定中间位置的数（见踩坑记录）；
1. 此时左右指针分别指向**剩余部分**的首尾位置；此时若三数之和小于目标值，则右移左指针；若大于目标值，则左移右指针；

- 为避免存入重复三元组，需要循环跳过重复元素；可以使用 set 去重，但这不是考察要点，其次也存在效率问题；
- 适当进行剪枝可以提升性能；

</details>

<details><summary><b>备忘</b></summary> 

1. 为什么不要固定中间位置的数
    - 固定第一个或最后一个数可以**缩小**每次遍历双指针的范围；
    - 但是固定中间位置的数则不会，这会带来额外的判重操作；
    
    ```python
    # 固定第一个数
    for i in range(L - 2):
        lp, rp = i + 1, L - 1  # 左指针与 i 的位置相关
    
    # 固定中间位置的数
    for i in range(1, L - 1):
        lp, rp = 0, L - 1  # 左右指针始终不变
    ```

</details>

**代码**
```python
from typing import List

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        # 设置目标值
        target = 0

        # 排序
        nums = sorted(nums)

        # 结果
        ret = []

        L = len(nums)
        for i in range(L - 2):  # 固定第一个数，注意范围
            # 剪枝（在 LeetCode 提供的用例上提升非常明显）
            if nums[i] > target: break

            # 设置左右指针
            l, r = i + 1, L - 1

            # 跟上一个值比较，如果相同则跳过
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            while l < r:

                s = nums[i] + nums[l] + nums[r]
                if s == target:
                    ret.append([nums[i], nums[l], nums[r]])

                    # 同时移动双指针
                    l += 1
                    r -= 1

                    # 如果跟上一个值相同，就跳过
                    while l < r and nums[l] == nums[l - 1]: l += 1
                    while l < r and nums[r] == nums[r + 1]: r -= 1
                elif s < target:
                    l += 1
                else:  # s > target
                    r -= 1

        return ret

```


### 最接近的三数之和（3Sum Closest）
> 最接近的三数之和 - 力扣（LeetCode） | https://leetcode-cn.com/problems/3sum-closest/

**问题描述**
```text
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

示例：
    输入：nums = [-1,2,1,-4], target = 1
    输出：2
    解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

提示：
    3 <= nums.length <= 10^3
    -10^3 <= nums[i] <= 10^3
    -10^4 <= target <= 10^4
```

<details><summary><b>算法简述</b></summary> 

1. 先对数组排序，然后用前三个数的和初始化返回值 ret；
1. 先固定第一个数字，然后左右双指针遍历剩余部分；
1. 若此时三数之和小于目标值，则右移左指针；若大于目标值，则左移右指针；
    - 如果等于则直接返回结果，结束程序；
1. 期间如果当前和比 ret 更接近目标值，则更新 ret；

- 利用单调性进行剪枝能大幅提升性能（本题中这一点可能比双指针遍历更重要）

</details>

<details><summary><b>备忘</b></summary> 

1. 如何利用单调性剪枝
    - 记每轮固定的值为 $n_i$，左右指针指向的值为 $n_l$ 和 $n_r$；则 s = i + l + r
    - 在经过排序后，每轮迭代时，三数之和的最大值和最小值是确定的；
        - min_s = i + 
    - 如果最小值比目标值大，那么后面无论怎么移动双指针，差值都只会越来越大；最大值比目标值小时同理；
    - 但两者又有不同：在固定第一个数的情况下，已经找不到差值更小的三元组了，所以此时可以提前结束程序，但是还可以找到

</details>



**代码**
```python
from typing import List

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums = sorted(nums)

        L = len(nums)
        ret = nums[0] + nums[1] + nums[2]  # 初始化，len(nums) >= 3
        for i in range(L - 2):

            # 跳过重复元素
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            # 剪枝：利用单调性
            min_s = nums[i] + nums[i + 1] + nums[i + 2]  # 最小和
            if min_s > target:  # 如果最小和也大于 target，则剩余部分的差值肯定越来越大
                # 容易忽略的一步，注意此时也是有可能出现答案的
                if abs(min_s - target) < abs(ret - target):
                    ret = min_s
                break

            max_s = nums[i] + nums[L - 2] + nums[L - 1]  # 最大和
            if max_s < target:  # 如果最大和也小于 target，则剩余部分的差值肯定越来越大
                ret = max_s  # 此时最大和必然比已知的 ret 更接近目标值
                continue

            # 初始化双指针
            l, r = i + 1, L - 1
            while l < r:
                s = nums[i] + nums[l] + nums[r]
                if abs(s - target) < abs(ret - target):
                    ret = s

                if s < target:
                    l += 1
                    while l < r and nums[l] == nums[l - 1]: l += 1
                elif s > target:
                    r -= 1
                    while l < r and nums[r] == nums[r + 1]: r -= 1
                else:  # ret == target
                    return ret
        return ret

```


### 下一题
